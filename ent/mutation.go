// Code generated by ent, DO NOT EDIT.

package ent

import (
	"auto-trader/ent/portfolio"
	"auto-trader/ent/predicate"
	"auto-trader/ent/strategy"
	"auto-trader/ent/strategyexecution"
	"auto-trader/ent/strategyperformance"
	"auto-trader/ent/strategystatus"
	"auto-trader/ent/strategytemplate"
	"auto-trader/ent/user"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypePortfolio           = "Portfolio"
	TypeStrategy            = "Strategy"
	TypeStrategyExecution   = "StrategyExecution"
	TypeStrategyPerformance = "StrategyPerformance"
	TypeStrategyStatus      = "StrategyStatus"
	TypeStrategyTemplate    = "StrategyTemplate"
	TypeUser                = "User"
)

// PortfolioMutation represents an operation that mutates the Portfolio nodes in the graph.
type PortfolioMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	symbol         *string
	quantity       *decimal.Decimal
	average_price  *decimal.Decimal
	current_price  *decimal.Decimal
	market_value   *decimal.Decimal
	total_cost     *decimal.Decimal
	unrealized_pnl *decimal.Decimal
	realized_pnl   *decimal.Decimal
	last_updated   *time.Time
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	user           *uuid.UUID
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Portfolio, error)
	predicates     []predicate.Portfolio
}

var _ ent.Mutation = (*PortfolioMutation)(nil)

// portfolioOption allows management of the mutation configuration using functional options.
type portfolioOption func(*PortfolioMutation)

// newPortfolioMutation creates new mutation for the Portfolio entity.
func newPortfolioMutation(c config, op Op, opts ...portfolioOption) *PortfolioMutation {
	m := &PortfolioMutation{
		config:        c,
		op:            op,
		typ:           TypePortfolio,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPortfolioID sets the ID field of the mutation.
func withPortfolioID(id uuid.UUID) portfolioOption {
	return func(m *PortfolioMutation) {
		var (
			err   error
			once  sync.Once
			value *Portfolio
		)
		m.oldValue = func(ctx context.Context) (*Portfolio, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Portfolio.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPortfolio sets the old Portfolio of the mutation.
func withPortfolio(node *Portfolio) portfolioOption {
	return func(m *PortfolioMutation) {
		m.oldValue = func(context.Context) (*Portfolio, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PortfolioMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PortfolioMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Portfolio entities.
func (m *PortfolioMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PortfolioMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PortfolioMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Portfolio.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *PortfolioMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PortfolioMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PortfolioMutation) ResetUserID() {
	m.user = nil
}

// SetSymbol sets the "symbol" field.
func (m *PortfolioMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *PortfolioMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *PortfolioMutation) ResetSymbol() {
	m.symbol = nil
}

// SetQuantity sets the "quantity" field.
func (m *PortfolioMutation) SetQuantity(d decimal.Decimal) {
	m.quantity = &d
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *PortfolioMutation) Quantity() (r decimal.Decimal, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *PortfolioMutation) ResetQuantity() {
	m.quantity = nil
}

// SetAveragePrice sets the "average_price" field.
func (m *PortfolioMutation) SetAveragePrice(d decimal.Decimal) {
	m.average_price = &d
}

// AveragePrice returns the value of the "average_price" field in the mutation.
func (m *PortfolioMutation) AveragePrice() (r decimal.Decimal, exists bool) {
	v := m.average_price
	if v == nil {
		return
	}
	return *v, true
}

// OldAveragePrice returns the old "average_price" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldAveragePrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAveragePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAveragePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAveragePrice: %w", err)
	}
	return oldValue.AveragePrice, nil
}

// ResetAveragePrice resets all changes to the "average_price" field.
func (m *PortfolioMutation) ResetAveragePrice() {
	m.average_price = nil
}

// SetCurrentPrice sets the "current_price" field.
func (m *PortfolioMutation) SetCurrentPrice(d decimal.Decimal) {
	m.current_price = &d
}

// CurrentPrice returns the value of the "current_price" field in the mutation.
func (m *PortfolioMutation) CurrentPrice() (r decimal.Decimal, exists bool) {
	v := m.current_price
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPrice returns the old "current_price" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldCurrentPrice(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPrice: %w", err)
	}
	return oldValue.CurrentPrice, nil
}

// ClearCurrentPrice clears the value of the "current_price" field.
func (m *PortfolioMutation) ClearCurrentPrice() {
	m.current_price = nil
	m.clearedFields[portfolio.FieldCurrentPrice] = struct{}{}
}

// CurrentPriceCleared returns if the "current_price" field was cleared in this mutation.
func (m *PortfolioMutation) CurrentPriceCleared() bool {
	_, ok := m.clearedFields[portfolio.FieldCurrentPrice]
	return ok
}

// ResetCurrentPrice resets all changes to the "current_price" field.
func (m *PortfolioMutation) ResetCurrentPrice() {
	m.current_price = nil
	delete(m.clearedFields, portfolio.FieldCurrentPrice)
}

// SetMarketValue sets the "market_value" field.
func (m *PortfolioMutation) SetMarketValue(d decimal.Decimal) {
	m.market_value = &d
}

// MarketValue returns the value of the "market_value" field in the mutation.
func (m *PortfolioMutation) MarketValue() (r decimal.Decimal, exists bool) {
	v := m.market_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketValue returns the old "market_value" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldMarketValue(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarketValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarketValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketValue: %w", err)
	}
	return oldValue.MarketValue, nil
}

// ResetMarketValue resets all changes to the "market_value" field.
func (m *PortfolioMutation) ResetMarketValue() {
	m.market_value = nil
}

// SetTotalCost sets the "total_cost" field.
func (m *PortfolioMutation) SetTotalCost(d decimal.Decimal) {
	m.total_cost = &d
}

// TotalCost returns the value of the "total_cost" field in the mutation.
func (m *PortfolioMutation) TotalCost() (r decimal.Decimal, exists bool) {
	v := m.total_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCost returns the old "total_cost" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldTotalCost(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCost: %w", err)
	}
	return oldValue.TotalCost, nil
}

// ResetTotalCost resets all changes to the "total_cost" field.
func (m *PortfolioMutation) ResetTotalCost() {
	m.total_cost = nil
}

// SetUnrealizedPnl sets the "unrealized_pnl" field.
func (m *PortfolioMutation) SetUnrealizedPnl(d decimal.Decimal) {
	m.unrealized_pnl = &d
}

// UnrealizedPnl returns the value of the "unrealized_pnl" field in the mutation.
func (m *PortfolioMutation) UnrealizedPnl() (r decimal.Decimal, exists bool) {
	v := m.unrealized_pnl
	if v == nil {
		return
	}
	return *v, true
}

// OldUnrealizedPnl returns the old "unrealized_pnl" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldUnrealizedPnl(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnrealizedPnl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnrealizedPnl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnrealizedPnl: %w", err)
	}
	return oldValue.UnrealizedPnl, nil
}

// ResetUnrealizedPnl resets all changes to the "unrealized_pnl" field.
func (m *PortfolioMutation) ResetUnrealizedPnl() {
	m.unrealized_pnl = nil
}

// SetRealizedPnl sets the "realized_pnl" field.
func (m *PortfolioMutation) SetRealizedPnl(d decimal.Decimal) {
	m.realized_pnl = &d
}

// RealizedPnl returns the value of the "realized_pnl" field in the mutation.
func (m *PortfolioMutation) RealizedPnl() (r decimal.Decimal, exists bool) {
	v := m.realized_pnl
	if v == nil {
		return
	}
	return *v, true
}

// OldRealizedPnl returns the old "realized_pnl" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldRealizedPnl(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealizedPnl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealizedPnl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealizedPnl: %w", err)
	}
	return oldValue.RealizedPnl, nil
}

// ResetRealizedPnl resets all changes to the "realized_pnl" field.
func (m *PortfolioMutation) ResetRealizedPnl() {
	m.realized_pnl = nil
}

// SetLastUpdated sets the "last_updated" field.
func (m *PortfolioMutation) SetLastUpdated(t time.Time) {
	m.last_updated = &t
}

// LastUpdated returns the value of the "last_updated" field in the mutation.
func (m *PortfolioMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "last_updated" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "last_updated" field.
func (m *PortfolioMutation) ResetLastUpdated() {
	m.last_updated = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PortfolioMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PortfolioMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PortfolioMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[portfolio.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PortfolioMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[portfolio.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PortfolioMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, portfolio.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PortfolioMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PortfolioMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PortfolioMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[portfolio.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PortfolioMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[portfolio.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PortfolioMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, portfolio.FieldUpdatedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *PortfolioMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[portfolio.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PortfolioMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PortfolioMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PortfolioMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PortfolioMutation builder.
func (m *PortfolioMutation) Where(ps ...predicate.Portfolio) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PortfolioMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PortfolioMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Portfolio, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PortfolioMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PortfolioMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Portfolio).
func (m *PortfolioMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PortfolioMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user != nil {
		fields = append(fields, portfolio.FieldUserID)
	}
	if m.symbol != nil {
		fields = append(fields, portfolio.FieldSymbol)
	}
	if m.quantity != nil {
		fields = append(fields, portfolio.FieldQuantity)
	}
	if m.average_price != nil {
		fields = append(fields, portfolio.FieldAveragePrice)
	}
	if m.current_price != nil {
		fields = append(fields, portfolio.FieldCurrentPrice)
	}
	if m.market_value != nil {
		fields = append(fields, portfolio.FieldMarketValue)
	}
	if m.total_cost != nil {
		fields = append(fields, portfolio.FieldTotalCost)
	}
	if m.unrealized_pnl != nil {
		fields = append(fields, portfolio.FieldUnrealizedPnl)
	}
	if m.realized_pnl != nil {
		fields = append(fields, portfolio.FieldRealizedPnl)
	}
	if m.last_updated != nil {
		fields = append(fields, portfolio.FieldLastUpdated)
	}
	if m.created_at != nil {
		fields = append(fields, portfolio.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, portfolio.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PortfolioMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case portfolio.FieldUserID:
		return m.UserID()
	case portfolio.FieldSymbol:
		return m.Symbol()
	case portfolio.FieldQuantity:
		return m.Quantity()
	case portfolio.FieldAveragePrice:
		return m.AveragePrice()
	case portfolio.FieldCurrentPrice:
		return m.CurrentPrice()
	case portfolio.FieldMarketValue:
		return m.MarketValue()
	case portfolio.FieldTotalCost:
		return m.TotalCost()
	case portfolio.FieldUnrealizedPnl:
		return m.UnrealizedPnl()
	case portfolio.FieldRealizedPnl:
		return m.RealizedPnl()
	case portfolio.FieldLastUpdated:
		return m.LastUpdated()
	case portfolio.FieldCreatedAt:
		return m.CreatedAt()
	case portfolio.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PortfolioMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case portfolio.FieldUserID:
		return m.OldUserID(ctx)
	case portfolio.FieldSymbol:
		return m.OldSymbol(ctx)
	case portfolio.FieldQuantity:
		return m.OldQuantity(ctx)
	case portfolio.FieldAveragePrice:
		return m.OldAveragePrice(ctx)
	case portfolio.FieldCurrentPrice:
		return m.OldCurrentPrice(ctx)
	case portfolio.FieldMarketValue:
		return m.OldMarketValue(ctx)
	case portfolio.FieldTotalCost:
		return m.OldTotalCost(ctx)
	case portfolio.FieldUnrealizedPnl:
		return m.OldUnrealizedPnl(ctx)
	case portfolio.FieldRealizedPnl:
		return m.OldRealizedPnl(ctx)
	case portfolio.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	case portfolio.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case portfolio.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Portfolio field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioMutation) SetField(name string, value ent.Value) error {
	switch name {
	case portfolio.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case portfolio.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case portfolio.FieldQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case portfolio.FieldAveragePrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAveragePrice(v)
		return nil
	case portfolio.FieldCurrentPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPrice(v)
		return nil
	case portfolio.FieldMarketValue:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketValue(v)
		return nil
	case portfolio.FieldTotalCost:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCost(v)
		return nil
	case portfolio.FieldUnrealizedPnl:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnrealizedPnl(v)
		return nil
	case portfolio.FieldRealizedPnl:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealizedPnl(v)
		return nil
	case portfolio.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	case portfolio.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case portfolio.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Portfolio field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PortfolioMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PortfolioMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Portfolio numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PortfolioMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(portfolio.FieldCurrentPrice) {
		fields = append(fields, portfolio.FieldCurrentPrice)
	}
	if m.FieldCleared(portfolio.FieldCreatedAt) {
		fields = append(fields, portfolio.FieldCreatedAt)
	}
	if m.FieldCleared(portfolio.FieldUpdatedAt) {
		fields = append(fields, portfolio.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PortfolioMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PortfolioMutation) ClearField(name string) error {
	switch name {
	case portfolio.FieldCurrentPrice:
		m.ClearCurrentPrice()
		return nil
	case portfolio.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case portfolio.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Portfolio nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PortfolioMutation) ResetField(name string) error {
	switch name {
	case portfolio.FieldUserID:
		m.ResetUserID()
		return nil
	case portfolio.FieldSymbol:
		m.ResetSymbol()
		return nil
	case portfolio.FieldQuantity:
		m.ResetQuantity()
		return nil
	case portfolio.FieldAveragePrice:
		m.ResetAveragePrice()
		return nil
	case portfolio.FieldCurrentPrice:
		m.ResetCurrentPrice()
		return nil
	case portfolio.FieldMarketValue:
		m.ResetMarketValue()
		return nil
	case portfolio.FieldTotalCost:
		m.ResetTotalCost()
		return nil
	case portfolio.FieldUnrealizedPnl:
		m.ResetUnrealizedPnl()
		return nil
	case portfolio.FieldRealizedPnl:
		m.ResetRealizedPnl()
		return nil
	case portfolio.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	case portfolio.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case portfolio.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Portfolio field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PortfolioMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, portfolio.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PortfolioMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case portfolio.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PortfolioMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PortfolioMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PortfolioMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, portfolio.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PortfolioMutation) EdgeCleared(name string) bool {
	switch name {
	case portfolio.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PortfolioMutation) ClearEdge(name string) error {
	switch name {
	case portfolio.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Portfolio unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PortfolioMutation) ResetEdge(name string) error {
	switch name {
	case portfolio.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Portfolio edge %s", name)
}

// StrategyMutation represents an operation that mutates the Strategy nodes in the graph.
type StrategyMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	strategy_id        *string
	name               *string
	description        *string
	symbol             *string
	user_inputs        *map[string]interface{}
	settings           *map[string]interface{}
	active             *bool
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	user               *uuid.UUID
	cleareduser        bool
	template           *uuid.UUID
	clearedtemplate    bool
	executions         map[int64]struct{}
	removedexecutions  map[int64]struct{}
	clearedexecutions  bool
	performance        *int
	clearedperformance bool
	status             *int
	clearedstatus      bool
	done               bool
	oldValue           func(context.Context) (*Strategy, error)
	predicates         []predicate.Strategy
}

var _ ent.Mutation = (*StrategyMutation)(nil)

// strategyOption allows management of the mutation configuration using functional options.
type strategyOption func(*StrategyMutation)

// newStrategyMutation creates new mutation for the Strategy entity.
func newStrategyMutation(c config, op Op, opts ...strategyOption) *StrategyMutation {
	m := &StrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategyID sets the ID field of the mutation.
func withStrategyID(id uuid.UUID) strategyOption {
	return func(m *StrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *Strategy
		)
		m.oldValue = func(ctx context.Context) (*Strategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Strategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategy sets the old Strategy of the mutation.
func withStrategy(node *Strategy) strategyOption {
	return func(m *StrategyMutation) {
		m.oldValue = func(context.Context) (*Strategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Strategy entities.
func (m *StrategyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Strategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *StrategyMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *StrategyMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *StrategyMutation) ResetUserID() {
	m.user = nil
}

// SetStrategyID sets the "strategy_id" field.
func (m *StrategyMutation) SetStrategyID(s string) {
	m.strategy_id = &s
}

// StrategyID returns the value of the "strategy_id" field in the mutation.
func (m *StrategyMutation) StrategyID() (r string, exists bool) {
	v := m.strategy_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyID returns the old "strategy_id" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldStrategyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyID: %w", err)
	}
	return oldValue.StrategyID, nil
}

// ResetStrategyID resets all changes to the "strategy_id" field.
func (m *StrategyMutation) ResetStrategyID() {
	m.strategy_id = nil
}

// SetTemplateID sets the "template_id" field.
func (m *StrategyMutation) SetTemplateID(u uuid.UUID) {
	m.template = &u
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *StrategyMutation) TemplateID() (r uuid.UUID, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldTemplateID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ClearTemplateID clears the value of the "template_id" field.
func (m *StrategyMutation) ClearTemplateID() {
	m.template = nil
	m.clearedFields[strategy.FieldTemplateID] = struct{}{}
}

// TemplateIDCleared returns if the "template_id" field was cleared in this mutation.
func (m *StrategyMutation) TemplateIDCleared() bool {
	_, ok := m.clearedFields[strategy.FieldTemplateID]
	return ok
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *StrategyMutation) ResetTemplateID() {
	m.template = nil
	delete(m.clearedFields, strategy.FieldTemplateID)
}

// SetName sets the "name" field.
func (m *StrategyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StrategyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StrategyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *StrategyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StrategyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StrategyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[strategy.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StrategyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[strategy.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StrategyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, strategy.FieldDescription)
}

// SetSymbol sets the "symbol" field.
func (m *StrategyMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *StrategyMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *StrategyMutation) ResetSymbol() {
	m.symbol = nil
}

// SetUserInputs sets the "user_inputs" field.
func (m *StrategyMutation) SetUserInputs(value map[string]interface{}) {
	m.user_inputs = &value
}

// UserInputs returns the value of the "user_inputs" field in the mutation.
func (m *StrategyMutation) UserInputs() (r map[string]interface{}, exists bool) {
	v := m.user_inputs
	if v == nil {
		return
	}
	return *v, true
}

// OldUserInputs returns the old "user_inputs" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldUserInputs(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserInputs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserInputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserInputs: %w", err)
	}
	return oldValue.UserInputs, nil
}

// ResetUserInputs resets all changes to the "user_inputs" field.
func (m *StrategyMutation) ResetUserInputs() {
	m.user_inputs = nil
}

// SetSettings sets the "settings" field.
func (m *StrategyMutation) SetSettings(value map[string]interface{}) {
	m.settings = &value
}

// Settings returns the value of the "settings" field in the mutation.
func (m *StrategyMutation) Settings() (r map[string]interface{}, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *StrategyMutation) ResetSettings() {
	m.settings = nil
}

// SetActive sets the "active" field.
func (m *StrategyMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *StrategyMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *StrategyMutation) ResetActive() {
	m.active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StrategyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StrategyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *StrategyMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[strategy.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *StrategyMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[strategy.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StrategyMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, strategy.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StrategyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StrategyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *StrategyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[strategy.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *StrategyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[strategy.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StrategyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, strategy.FieldUpdatedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *StrategyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[strategy.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *StrategyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *StrategyMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *StrategyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearTemplate clears the "template" edge to the StrategyTemplate entity.
func (m *StrategyMutation) ClearTemplate() {
	m.clearedtemplate = true
	m.clearedFields[strategy.FieldTemplateID] = struct{}{}
}

// TemplateCleared reports if the "template" edge to the StrategyTemplate entity was cleared.
func (m *StrategyMutation) TemplateCleared() bool {
	return m.TemplateIDCleared() || m.clearedtemplate
}

// TemplateIDs returns the "template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *StrategyMutation) TemplateIDs() (ids []uuid.UUID) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate resets all changes to the "template" edge.
func (m *StrategyMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// AddExecutionIDs adds the "executions" edge to the StrategyExecution entity by ids.
func (m *StrategyMutation) AddExecutionIDs(ids ...int64) {
	if m.executions == nil {
		m.executions = make(map[int64]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the StrategyExecution entity.
func (m *StrategyMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the StrategyExecution entity was cleared.
func (m *StrategyMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the StrategyExecution entity by IDs.
func (m *StrategyMutation) RemoveExecutionIDs(ids ...int64) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the StrategyExecution entity.
func (m *StrategyMutation) RemovedExecutionsIDs() (ids []int64) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *StrategyMutation) ExecutionsIDs() (ids []int64) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *StrategyMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// SetPerformanceID sets the "performance" edge to the StrategyPerformance entity by id.
func (m *StrategyMutation) SetPerformanceID(id int) {
	m.performance = &id
}

// ClearPerformance clears the "performance" edge to the StrategyPerformance entity.
func (m *StrategyMutation) ClearPerformance() {
	m.clearedperformance = true
}

// PerformanceCleared reports if the "performance" edge to the StrategyPerformance entity was cleared.
func (m *StrategyMutation) PerformanceCleared() bool {
	return m.clearedperformance
}

// PerformanceID returns the "performance" edge ID in the mutation.
func (m *StrategyMutation) PerformanceID() (id int, exists bool) {
	if m.performance != nil {
		return *m.performance, true
	}
	return
}

// PerformanceIDs returns the "performance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PerformanceID instead. It exists only for internal usage by the builders.
func (m *StrategyMutation) PerformanceIDs() (ids []int) {
	if id := m.performance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPerformance resets all changes to the "performance" edge.
func (m *StrategyMutation) ResetPerformance() {
	m.performance = nil
	m.clearedperformance = false
}

// SetStatusID sets the "status" edge to the StrategyStatus entity by id.
func (m *StrategyMutation) SetStatusID(id int) {
	m.status = &id
}

// ClearStatus clears the "status" edge to the StrategyStatus entity.
func (m *StrategyMutation) ClearStatus() {
	m.clearedstatus = true
}

// StatusCleared reports if the "status" edge to the StrategyStatus entity was cleared.
func (m *StrategyMutation) StatusCleared() bool {
	return m.clearedstatus
}

// StatusID returns the "status" edge ID in the mutation.
func (m *StrategyMutation) StatusID() (id int, exists bool) {
	if m.status != nil {
		return *m.status, true
	}
	return
}

// StatusIDs returns the "status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusID instead. It exists only for internal usage by the builders.
func (m *StrategyMutation) StatusIDs() (ids []int) {
	if id := m.status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatus resets all changes to the "status" edge.
func (m *StrategyMutation) ResetStatus() {
	m.status = nil
	m.clearedstatus = false
}

// Where appends a list predicates to the StrategyMutation builder.
func (m *StrategyMutation) Where(ps ...predicate.Strategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Strategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Strategy).
func (m *StrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategyMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user != nil {
		fields = append(fields, strategy.FieldUserID)
	}
	if m.strategy_id != nil {
		fields = append(fields, strategy.FieldStrategyID)
	}
	if m.template != nil {
		fields = append(fields, strategy.FieldTemplateID)
	}
	if m.name != nil {
		fields = append(fields, strategy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, strategy.FieldDescription)
	}
	if m.symbol != nil {
		fields = append(fields, strategy.FieldSymbol)
	}
	if m.user_inputs != nil {
		fields = append(fields, strategy.FieldUserInputs)
	}
	if m.settings != nil {
		fields = append(fields, strategy.FieldSettings)
	}
	if m.active != nil {
		fields = append(fields, strategy.FieldActive)
	}
	if m.created_at != nil {
		fields = append(fields, strategy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, strategy.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategy.FieldUserID:
		return m.UserID()
	case strategy.FieldStrategyID:
		return m.StrategyID()
	case strategy.FieldTemplateID:
		return m.TemplateID()
	case strategy.FieldName:
		return m.Name()
	case strategy.FieldDescription:
		return m.Description()
	case strategy.FieldSymbol:
		return m.Symbol()
	case strategy.FieldUserInputs:
		return m.UserInputs()
	case strategy.FieldSettings:
		return m.Settings()
	case strategy.FieldActive:
		return m.Active()
	case strategy.FieldCreatedAt:
		return m.CreatedAt()
	case strategy.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategy.FieldUserID:
		return m.OldUserID(ctx)
	case strategy.FieldStrategyID:
		return m.OldStrategyID(ctx)
	case strategy.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case strategy.FieldName:
		return m.OldName(ctx)
	case strategy.FieldDescription:
		return m.OldDescription(ctx)
	case strategy.FieldSymbol:
		return m.OldSymbol(ctx)
	case strategy.FieldUserInputs:
		return m.OldUserInputs(ctx)
	case strategy.FieldSettings:
		return m.OldSettings(ctx)
	case strategy.FieldActive:
		return m.OldActive(ctx)
	case strategy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case strategy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Strategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategy.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case strategy.FieldStrategyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyID(v)
		return nil
	case strategy.FieldTemplateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case strategy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case strategy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case strategy.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case strategy.FieldUserInputs:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserInputs(v)
		return nil
	case strategy.FieldSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case strategy.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case strategy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case strategy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Strategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(strategy.FieldTemplateID) {
		fields = append(fields, strategy.FieldTemplateID)
	}
	if m.FieldCleared(strategy.FieldDescription) {
		fields = append(fields, strategy.FieldDescription)
	}
	if m.FieldCleared(strategy.FieldCreatedAt) {
		fields = append(fields, strategy.FieldCreatedAt)
	}
	if m.FieldCleared(strategy.FieldUpdatedAt) {
		fields = append(fields, strategy.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategyMutation) ClearField(name string) error {
	switch name {
	case strategy.FieldTemplateID:
		m.ClearTemplateID()
		return nil
	case strategy.FieldDescription:
		m.ClearDescription()
		return nil
	case strategy.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case strategy.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Strategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategyMutation) ResetField(name string) error {
	switch name {
	case strategy.FieldUserID:
		m.ResetUserID()
		return nil
	case strategy.FieldStrategyID:
		m.ResetStrategyID()
		return nil
	case strategy.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case strategy.FieldName:
		m.ResetName()
		return nil
	case strategy.FieldDescription:
		m.ResetDescription()
		return nil
	case strategy.FieldSymbol:
		m.ResetSymbol()
		return nil
	case strategy.FieldUserInputs:
		m.ResetUserInputs()
		return nil
	case strategy.FieldSettings:
		m.ResetSettings()
		return nil
	case strategy.FieldActive:
		m.ResetActive()
		return nil
	case strategy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case strategy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, strategy.EdgeUser)
	}
	if m.template != nil {
		edges = append(edges, strategy.EdgeTemplate)
	}
	if m.executions != nil {
		edges = append(edges, strategy.EdgeExecutions)
	}
	if m.performance != nil {
		edges = append(edges, strategy.EdgePerformance)
	}
	if m.status != nil {
		edges = append(edges, strategy.EdgeStatus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case strategy.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case strategy.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	case strategy.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case strategy.EdgePerformance:
		if id := m.performance; id != nil {
			return []ent.Value{*id}
		}
	case strategy.EdgeStatus:
		if id := m.status; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedexecutions != nil {
		edges = append(edges, strategy.EdgeExecutions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case strategy.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, strategy.EdgeUser)
	}
	if m.clearedtemplate {
		edges = append(edges, strategy.EdgeTemplate)
	}
	if m.clearedexecutions {
		edges = append(edges, strategy.EdgeExecutions)
	}
	if m.clearedperformance {
		edges = append(edges, strategy.EdgePerformance)
	}
	if m.clearedstatus {
		edges = append(edges, strategy.EdgeStatus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategyMutation) EdgeCleared(name string) bool {
	switch name {
	case strategy.EdgeUser:
		return m.cleareduser
	case strategy.EdgeTemplate:
		return m.clearedtemplate
	case strategy.EdgeExecutions:
		return m.clearedexecutions
	case strategy.EdgePerformance:
		return m.clearedperformance
	case strategy.EdgeStatus:
		return m.clearedstatus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategyMutation) ClearEdge(name string) error {
	switch name {
	case strategy.EdgeUser:
		m.ClearUser()
		return nil
	case strategy.EdgeTemplate:
		m.ClearTemplate()
		return nil
	case strategy.EdgePerformance:
		m.ClearPerformance()
		return nil
	case strategy.EdgeStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Strategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategyMutation) ResetEdge(name string) error {
	switch name {
	case strategy.EdgeUser:
		m.ResetUser()
		return nil
	case strategy.EdgeTemplate:
		m.ResetTemplate()
		return nil
	case strategy.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case strategy.EdgePerformance:
		m.ResetPerformance()
		return nil
	case strategy.EdgeStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Strategy edge %s", name)
}

// StrategyExecutionMutation represents an operation that mutates the StrategyExecution nodes in the graph.
type StrategyExecutionMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	symbol          *string
	action          *strategyexecution.Action
	price           *decimal.Decimal
	quantity        *int
	addquantity     *int
	reasoning       *string
	executed_at     *time.Time
	clearedFields   map[string]struct{}
	strategy        *uuid.UUID
	clearedstrategy bool
	done            bool
	oldValue        func(context.Context) (*StrategyExecution, error)
	predicates      []predicate.StrategyExecution
}

var _ ent.Mutation = (*StrategyExecutionMutation)(nil)

// strategyexecutionOption allows management of the mutation configuration using functional options.
type strategyexecutionOption func(*StrategyExecutionMutation)

// newStrategyExecutionMutation creates new mutation for the StrategyExecution entity.
func newStrategyExecutionMutation(c config, op Op, opts ...strategyexecutionOption) *StrategyExecutionMutation {
	m := &StrategyExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategyExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategyExecutionID sets the ID field of the mutation.
func withStrategyExecutionID(id int64) strategyexecutionOption {
	return func(m *StrategyExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *StrategyExecution
		)
		m.oldValue = func(ctx context.Context) (*StrategyExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StrategyExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategyExecution sets the old StrategyExecution of the mutation.
func withStrategyExecution(node *StrategyExecution) strategyexecutionOption {
	return func(m *StrategyExecutionMutation) {
		m.oldValue = func(context.Context) (*StrategyExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategyExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategyExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StrategyExecution entities.
func (m *StrategyExecutionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategyExecutionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategyExecutionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StrategyExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStrategyID sets the "strategy_id" field.
func (m *StrategyExecutionMutation) SetStrategyID(u uuid.UUID) {
	m.strategy = &u
}

// StrategyID returns the value of the "strategy_id" field in the mutation.
func (m *StrategyExecutionMutation) StrategyID() (r uuid.UUID, exists bool) {
	v := m.strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyID returns the old "strategy_id" field's value of the StrategyExecution entity.
// If the StrategyExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyExecutionMutation) OldStrategyID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyID: %w", err)
	}
	return oldValue.StrategyID, nil
}

// ClearStrategyID clears the value of the "strategy_id" field.
func (m *StrategyExecutionMutation) ClearStrategyID() {
	m.strategy = nil
	m.clearedFields[strategyexecution.FieldStrategyID] = struct{}{}
}

// StrategyIDCleared returns if the "strategy_id" field was cleared in this mutation.
func (m *StrategyExecutionMutation) StrategyIDCleared() bool {
	_, ok := m.clearedFields[strategyexecution.FieldStrategyID]
	return ok
}

// ResetStrategyID resets all changes to the "strategy_id" field.
func (m *StrategyExecutionMutation) ResetStrategyID() {
	m.strategy = nil
	delete(m.clearedFields, strategyexecution.FieldStrategyID)
}

// SetSymbol sets the "symbol" field.
func (m *StrategyExecutionMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *StrategyExecutionMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the StrategyExecution entity.
// If the StrategyExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyExecutionMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *StrategyExecutionMutation) ResetSymbol() {
	m.symbol = nil
}

// SetAction sets the "action" field.
func (m *StrategyExecutionMutation) SetAction(s strategyexecution.Action) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *StrategyExecutionMutation) Action() (r strategyexecution.Action, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the StrategyExecution entity.
// If the StrategyExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyExecutionMutation) OldAction(ctx context.Context) (v strategyexecution.Action, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *StrategyExecutionMutation) ResetAction() {
	m.action = nil
}

// SetPrice sets the "price" field.
func (m *StrategyExecutionMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *StrategyExecutionMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the StrategyExecution entity.
// If the StrategyExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyExecutionMutation) OldPrice(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *StrategyExecutionMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[strategyexecution.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *StrategyExecutionMutation) PriceCleared() bool {
	_, ok := m.clearedFields[strategyexecution.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *StrategyExecutionMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, strategyexecution.FieldPrice)
}

// SetQuantity sets the "quantity" field.
func (m *StrategyExecutionMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *StrategyExecutionMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the StrategyExecution entity.
// If the StrategyExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyExecutionMutation) OldQuantity(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *StrategyExecutionMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *StrategyExecutionMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantity clears the value of the "quantity" field.
func (m *StrategyExecutionMutation) ClearQuantity() {
	m.quantity = nil
	m.addquantity = nil
	m.clearedFields[strategyexecution.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *StrategyExecutionMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[strategyexecution.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *StrategyExecutionMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
	delete(m.clearedFields, strategyexecution.FieldQuantity)
}

// SetReasoning sets the "reasoning" field.
func (m *StrategyExecutionMutation) SetReasoning(s string) {
	m.reasoning = &s
}

// Reasoning returns the value of the "reasoning" field in the mutation.
func (m *StrategyExecutionMutation) Reasoning() (r string, exists bool) {
	v := m.reasoning
	if v == nil {
		return
	}
	return *v, true
}

// OldReasoning returns the old "reasoning" field's value of the StrategyExecution entity.
// If the StrategyExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyExecutionMutation) OldReasoning(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReasoning is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReasoning requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasoning: %w", err)
	}
	return oldValue.Reasoning, nil
}

// ClearReasoning clears the value of the "reasoning" field.
func (m *StrategyExecutionMutation) ClearReasoning() {
	m.reasoning = nil
	m.clearedFields[strategyexecution.FieldReasoning] = struct{}{}
}

// ReasoningCleared returns if the "reasoning" field was cleared in this mutation.
func (m *StrategyExecutionMutation) ReasoningCleared() bool {
	_, ok := m.clearedFields[strategyexecution.FieldReasoning]
	return ok
}

// ResetReasoning resets all changes to the "reasoning" field.
func (m *StrategyExecutionMutation) ResetReasoning() {
	m.reasoning = nil
	delete(m.clearedFields, strategyexecution.FieldReasoning)
}

// SetExecutedAt sets the "executed_at" field.
func (m *StrategyExecutionMutation) SetExecutedAt(t time.Time) {
	m.executed_at = &t
}

// ExecutedAt returns the value of the "executed_at" field in the mutation.
func (m *StrategyExecutionMutation) ExecutedAt() (r time.Time, exists bool) {
	v := m.executed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutedAt returns the old "executed_at" field's value of the StrategyExecution entity.
// If the StrategyExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyExecutionMutation) OldExecutedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutedAt: %w", err)
	}
	return oldValue.ExecutedAt, nil
}

// ClearExecutedAt clears the value of the "executed_at" field.
func (m *StrategyExecutionMutation) ClearExecutedAt() {
	m.executed_at = nil
	m.clearedFields[strategyexecution.FieldExecutedAt] = struct{}{}
}

// ExecutedAtCleared returns if the "executed_at" field was cleared in this mutation.
func (m *StrategyExecutionMutation) ExecutedAtCleared() bool {
	_, ok := m.clearedFields[strategyexecution.FieldExecutedAt]
	return ok
}

// ResetExecutedAt resets all changes to the "executed_at" field.
func (m *StrategyExecutionMutation) ResetExecutedAt() {
	m.executed_at = nil
	delete(m.clearedFields, strategyexecution.FieldExecutedAt)
}

// ClearStrategy clears the "strategy" edge to the Strategy entity.
func (m *StrategyExecutionMutation) ClearStrategy() {
	m.clearedstrategy = true
	m.clearedFields[strategyexecution.FieldStrategyID] = struct{}{}
}

// StrategyCleared reports if the "strategy" edge to the Strategy entity was cleared.
func (m *StrategyExecutionMutation) StrategyCleared() bool {
	return m.StrategyIDCleared() || m.clearedstrategy
}

// StrategyIDs returns the "strategy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StrategyID instead. It exists only for internal usage by the builders.
func (m *StrategyExecutionMutation) StrategyIDs() (ids []uuid.UUID) {
	if id := m.strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStrategy resets all changes to the "strategy" edge.
func (m *StrategyExecutionMutation) ResetStrategy() {
	m.strategy = nil
	m.clearedstrategy = false
}

// Where appends a list predicates to the StrategyExecutionMutation builder.
func (m *StrategyExecutionMutation) Where(ps ...predicate.StrategyExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StrategyExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StrategyExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StrategyExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StrategyExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StrategyExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StrategyExecution).
func (m *StrategyExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategyExecutionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.strategy != nil {
		fields = append(fields, strategyexecution.FieldStrategyID)
	}
	if m.symbol != nil {
		fields = append(fields, strategyexecution.FieldSymbol)
	}
	if m.action != nil {
		fields = append(fields, strategyexecution.FieldAction)
	}
	if m.price != nil {
		fields = append(fields, strategyexecution.FieldPrice)
	}
	if m.quantity != nil {
		fields = append(fields, strategyexecution.FieldQuantity)
	}
	if m.reasoning != nil {
		fields = append(fields, strategyexecution.FieldReasoning)
	}
	if m.executed_at != nil {
		fields = append(fields, strategyexecution.FieldExecutedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategyExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategyexecution.FieldStrategyID:
		return m.StrategyID()
	case strategyexecution.FieldSymbol:
		return m.Symbol()
	case strategyexecution.FieldAction:
		return m.Action()
	case strategyexecution.FieldPrice:
		return m.Price()
	case strategyexecution.FieldQuantity:
		return m.Quantity()
	case strategyexecution.FieldReasoning:
		return m.Reasoning()
	case strategyexecution.FieldExecutedAt:
		return m.ExecutedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategyExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategyexecution.FieldStrategyID:
		return m.OldStrategyID(ctx)
	case strategyexecution.FieldSymbol:
		return m.OldSymbol(ctx)
	case strategyexecution.FieldAction:
		return m.OldAction(ctx)
	case strategyexecution.FieldPrice:
		return m.OldPrice(ctx)
	case strategyexecution.FieldQuantity:
		return m.OldQuantity(ctx)
	case strategyexecution.FieldReasoning:
		return m.OldReasoning(ctx)
	case strategyexecution.FieldExecutedAt:
		return m.OldExecutedAt(ctx)
	}
	return nil, fmt.Errorf("unknown StrategyExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategyexecution.FieldStrategyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyID(v)
		return nil
	case strategyexecution.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case strategyexecution.FieldAction:
		v, ok := value.(strategyexecution.Action)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case strategyexecution.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case strategyexecution.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case strategyexecution.FieldReasoning:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasoning(v)
		return nil
	case strategyexecution.FieldExecutedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StrategyExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategyExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, strategyexecution.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategyExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case strategyexecution.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case strategyexecution.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown StrategyExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategyExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(strategyexecution.FieldStrategyID) {
		fields = append(fields, strategyexecution.FieldStrategyID)
	}
	if m.FieldCleared(strategyexecution.FieldPrice) {
		fields = append(fields, strategyexecution.FieldPrice)
	}
	if m.FieldCleared(strategyexecution.FieldQuantity) {
		fields = append(fields, strategyexecution.FieldQuantity)
	}
	if m.FieldCleared(strategyexecution.FieldReasoning) {
		fields = append(fields, strategyexecution.FieldReasoning)
	}
	if m.FieldCleared(strategyexecution.FieldExecutedAt) {
		fields = append(fields, strategyexecution.FieldExecutedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategyExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategyExecutionMutation) ClearField(name string) error {
	switch name {
	case strategyexecution.FieldStrategyID:
		m.ClearStrategyID()
		return nil
	case strategyexecution.FieldPrice:
		m.ClearPrice()
		return nil
	case strategyexecution.FieldQuantity:
		m.ClearQuantity()
		return nil
	case strategyexecution.FieldReasoning:
		m.ClearReasoning()
		return nil
	case strategyexecution.FieldExecutedAt:
		m.ClearExecutedAt()
		return nil
	}
	return fmt.Errorf("unknown StrategyExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategyExecutionMutation) ResetField(name string) error {
	switch name {
	case strategyexecution.FieldStrategyID:
		m.ResetStrategyID()
		return nil
	case strategyexecution.FieldSymbol:
		m.ResetSymbol()
		return nil
	case strategyexecution.FieldAction:
		m.ResetAction()
		return nil
	case strategyexecution.FieldPrice:
		m.ResetPrice()
		return nil
	case strategyexecution.FieldQuantity:
		m.ResetQuantity()
		return nil
	case strategyexecution.FieldReasoning:
		m.ResetReasoning()
		return nil
	case strategyexecution.FieldExecutedAt:
		m.ResetExecutedAt()
		return nil
	}
	return fmt.Errorf("unknown StrategyExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategyExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.strategy != nil {
		edges = append(edges, strategyexecution.EdgeStrategy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategyExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case strategyexecution.EdgeStrategy:
		if id := m.strategy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategyExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategyExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategyExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstrategy {
		edges = append(edges, strategyexecution.EdgeStrategy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategyExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case strategyexecution.EdgeStrategy:
		return m.clearedstrategy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategyExecutionMutation) ClearEdge(name string) error {
	switch name {
	case strategyexecution.EdgeStrategy:
		m.ClearStrategy()
		return nil
	}
	return fmt.Errorf("unknown StrategyExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategyExecutionMutation) ResetEdge(name string) error {
	switch name {
	case strategyexecution.EdgeStrategy:
		m.ResetStrategy()
		return nil
	}
	return fmt.Errorf("unknown StrategyExecution edge %s", name)
}

// StrategyPerformanceMutation represents an operation that mutates the StrategyPerformance nodes in the graph.
type StrategyPerformanceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	total_return    *decimal.Decimal
	win_rate        *decimal.Decimal
	profit_loss     *decimal.Decimal
	trade_count     *int64
	addtrade_count  *int64
	last_trade_time *time.Time
	max_drawdown    *decimal.Decimal
	sharpe_ratio    *decimal.Decimal
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	strategy        *uuid.UUID
	clearedstrategy bool
	done            bool
	oldValue        func(context.Context) (*StrategyPerformance, error)
	predicates      []predicate.StrategyPerformance
}

var _ ent.Mutation = (*StrategyPerformanceMutation)(nil)

// strategyperformanceOption allows management of the mutation configuration using functional options.
type strategyperformanceOption func(*StrategyPerformanceMutation)

// newStrategyPerformanceMutation creates new mutation for the StrategyPerformance entity.
func newStrategyPerformanceMutation(c config, op Op, opts ...strategyperformanceOption) *StrategyPerformanceMutation {
	m := &StrategyPerformanceMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategyPerformance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategyPerformanceID sets the ID field of the mutation.
func withStrategyPerformanceID(id int) strategyperformanceOption {
	return func(m *StrategyPerformanceMutation) {
		var (
			err   error
			once  sync.Once
			value *StrategyPerformance
		)
		m.oldValue = func(ctx context.Context) (*StrategyPerformance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StrategyPerformance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategyPerformance sets the old StrategyPerformance of the mutation.
func withStrategyPerformance(node *StrategyPerformance) strategyperformanceOption {
	return func(m *StrategyPerformanceMutation) {
		m.oldValue = func(context.Context) (*StrategyPerformance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategyPerformanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategyPerformanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategyPerformanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategyPerformanceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StrategyPerformance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStrategyID sets the "strategy_id" field.
func (m *StrategyPerformanceMutation) SetStrategyID(u uuid.UUID) {
	m.strategy = &u
}

// StrategyID returns the value of the "strategy_id" field in the mutation.
func (m *StrategyPerformanceMutation) StrategyID() (r uuid.UUID, exists bool) {
	v := m.strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyID returns the old "strategy_id" field's value of the StrategyPerformance entity.
// If the StrategyPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyPerformanceMutation) OldStrategyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyID: %w", err)
	}
	return oldValue.StrategyID, nil
}

// ResetStrategyID resets all changes to the "strategy_id" field.
func (m *StrategyPerformanceMutation) ResetStrategyID() {
	m.strategy = nil
}

// SetTotalReturn sets the "total_return" field.
func (m *StrategyPerformanceMutation) SetTotalReturn(d decimal.Decimal) {
	m.total_return = &d
}

// TotalReturn returns the value of the "total_return" field in the mutation.
func (m *StrategyPerformanceMutation) TotalReturn() (r decimal.Decimal, exists bool) {
	v := m.total_return
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalReturn returns the old "total_return" field's value of the StrategyPerformance entity.
// If the StrategyPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyPerformanceMutation) OldTotalReturn(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalReturn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalReturn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalReturn: %w", err)
	}
	return oldValue.TotalReturn, nil
}

// ResetTotalReturn resets all changes to the "total_return" field.
func (m *StrategyPerformanceMutation) ResetTotalReturn() {
	m.total_return = nil
}

// SetWinRate sets the "win_rate" field.
func (m *StrategyPerformanceMutation) SetWinRate(d decimal.Decimal) {
	m.win_rate = &d
}

// WinRate returns the value of the "win_rate" field in the mutation.
func (m *StrategyPerformanceMutation) WinRate() (r decimal.Decimal, exists bool) {
	v := m.win_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldWinRate returns the old "win_rate" field's value of the StrategyPerformance entity.
// If the StrategyPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyPerformanceMutation) OldWinRate(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWinRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWinRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWinRate: %w", err)
	}
	return oldValue.WinRate, nil
}

// ResetWinRate resets all changes to the "win_rate" field.
func (m *StrategyPerformanceMutation) ResetWinRate() {
	m.win_rate = nil
}

// SetProfitLoss sets the "profit_loss" field.
func (m *StrategyPerformanceMutation) SetProfitLoss(d decimal.Decimal) {
	m.profit_loss = &d
}

// ProfitLoss returns the value of the "profit_loss" field in the mutation.
func (m *StrategyPerformanceMutation) ProfitLoss() (r decimal.Decimal, exists bool) {
	v := m.profit_loss
	if v == nil {
		return
	}
	return *v, true
}

// OldProfitLoss returns the old "profit_loss" field's value of the StrategyPerformance entity.
// If the StrategyPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyPerformanceMutation) OldProfitLoss(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfitLoss is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfitLoss requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfitLoss: %w", err)
	}
	return oldValue.ProfitLoss, nil
}

// ResetProfitLoss resets all changes to the "profit_loss" field.
func (m *StrategyPerformanceMutation) ResetProfitLoss() {
	m.profit_loss = nil
}

// SetTradeCount sets the "trade_count" field.
func (m *StrategyPerformanceMutation) SetTradeCount(i int64) {
	m.trade_count = &i
	m.addtrade_count = nil
}

// TradeCount returns the value of the "trade_count" field in the mutation.
func (m *StrategyPerformanceMutation) TradeCount() (r int64, exists bool) {
	v := m.trade_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTradeCount returns the old "trade_count" field's value of the StrategyPerformance entity.
// If the StrategyPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyPerformanceMutation) OldTradeCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTradeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTradeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradeCount: %w", err)
	}
	return oldValue.TradeCount, nil
}

// AddTradeCount adds i to the "trade_count" field.
func (m *StrategyPerformanceMutation) AddTradeCount(i int64) {
	if m.addtrade_count != nil {
		*m.addtrade_count += i
	} else {
		m.addtrade_count = &i
	}
}

// AddedTradeCount returns the value that was added to the "trade_count" field in this mutation.
func (m *StrategyPerformanceMutation) AddedTradeCount() (r int64, exists bool) {
	v := m.addtrade_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTradeCount resets all changes to the "trade_count" field.
func (m *StrategyPerformanceMutation) ResetTradeCount() {
	m.trade_count = nil
	m.addtrade_count = nil
}

// SetLastTradeTime sets the "last_trade_time" field.
func (m *StrategyPerformanceMutation) SetLastTradeTime(t time.Time) {
	m.last_trade_time = &t
}

// LastTradeTime returns the value of the "last_trade_time" field in the mutation.
func (m *StrategyPerformanceMutation) LastTradeTime() (r time.Time, exists bool) {
	v := m.last_trade_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastTradeTime returns the old "last_trade_time" field's value of the StrategyPerformance entity.
// If the StrategyPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyPerformanceMutation) OldLastTradeTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastTradeTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastTradeTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastTradeTime: %w", err)
	}
	return oldValue.LastTradeTime, nil
}

// ClearLastTradeTime clears the value of the "last_trade_time" field.
func (m *StrategyPerformanceMutation) ClearLastTradeTime() {
	m.last_trade_time = nil
	m.clearedFields[strategyperformance.FieldLastTradeTime] = struct{}{}
}

// LastTradeTimeCleared returns if the "last_trade_time" field was cleared in this mutation.
func (m *StrategyPerformanceMutation) LastTradeTimeCleared() bool {
	_, ok := m.clearedFields[strategyperformance.FieldLastTradeTime]
	return ok
}

// ResetLastTradeTime resets all changes to the "last_trade_time" field.
func (m *StrategyPerformanceMutation) ResetLastTradeTime() {
	m.last_trade_time = nil
	delete(m.clearedFields, strategyperformance.FieldLastTradeTime)
}

// SetMaxDrawdown sets the "max_drawdown" field.
func (m *StrategyPerformanceMutation) SetMaxDrawdown(d decimal.Decimal) {
	m.max_drawdown = &d
}

// MaxDrawdown returns the value of the "max_drawdown" field in the mutation.
func (m *StrategyPerformanceMutation) MaxDrawdown() (r decimal.Decimal, exists bool) {
	v := m.max_drawdown
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxDrawdown returns the old "max_drawdown" field's value of the StrategyPerformance entity.
// If the StrategyPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyPerformanceMutation) OldMaxDrawdown(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxDrawdown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxDrawdown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxDrawdown: %w", err)
	}
	return oldValue.MaxDrawdown, nil
}

// ResetMaxDrawdown resets all changes to the "max_drawdown" field.
func (m *StrategyPerformanceMutation) ResetMaxDrawdown() {
	m.max_drawdown = nil
}

// SetSharpeRatio sets the "sharpe_ratio" field.
func (m *StrategyPerformanceMutation) SetSharpeRatio(d decimal.Decimal) {
	m.sharpe_ratio = &d
}

// SharpeRatio returns the value of the "sharpe_ratio" field in the mutation.
func (m *StrategyPerformanceMutation) SharpeRatio() (r decimal.Decimal, exists bool) {
	v := m.sharpe_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldSharpeRatio returns the old "sharpe_ratio" field's value of the StrategyPerformance entity.
// If the StrategyPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyPerformanceMutation) OldSharpeRatio(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSharpeRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSharpeRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSharpeRatio: %w", err)
	}
	return oldValue.SharpeRatio, nil
}

// ResetSharpeRatio resets all changes to the "sharpe_ratio" field.
func (m *StrategyPerformanceMutation) ResetSharpeRatio() {
	m.sharpe_ratio = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StrategyPerformanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StrategyPerformanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StrategyPerformance entity.
// If the StrategyPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyPerformanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StrategyPerformanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StrategyPerformanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StrategyPerformanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StrategyPerformance entity.
// If the StrategyPerformance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyPerformanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StrategyPerformanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearStrategy clears the "strategy" edge to the Strategy entity.
func (m *StrategyPerformanceMutation) ClearStrategy() {
	m.clearedstrategy = true
	m.clearedFields[strategyperformance.FieldStrategyID] = struct{}{}
}

// StrategyCleared reports if the "strategy" edge to the Strategy entity was cleared.
func (m *StrategyPerformanceMutation) StrategyCleared() bool {
	return m.clearedstrategy
}

// StrategyIDs returns the "strategy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StrategyID instead. It exists only for internal usage by the builders.
func (m *StrategyPerformanceMutation) StrategyIDs() (ids []uuid.UUID) {
	if id := m.strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStrategy resets all changes to the "strategy" edge.
func (m *StrategyPerformanceMutation) ResetStrategy() {
	m.strategy = nil
	m.clearedstrategy = false
}

// Where appends a list predicates to the StrategyPerformanceMutation builder.
func (m *StrategyPerformanceMutation) Where(ps ...predicate.StrategyPerformance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StrategyPerformanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StrategyPerformanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StrategyPerformance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StrategyPerformanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StrategyPerformanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StrategyPerformance).
func (m *StrategyPerformanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategyPerformanceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.strategy != nil {
		fields = append(fields, strategyperformance.FieldStrategyID)
	}
	if m.total_return != nil {
		fields = append(fields, strategyperformance.FieldTotalReturn)
	}
	if m.win_rate != nil {
		fields = append(fields, strategyperformance.FieldWinRate)
	}
	if m.profit_loss != nil {
		fields = append(fields, strategyperformance.FieldProfitLoss)
	}
	if m.trade_count != nil {
		fields = append(fields, strategyperformance.FieldTradeCount)
	}
	if m.last_trade_time != nil {
		fields = append(fields, strategyperformance.FieldLastTradeTime)
	}
	if m.max_drawdown != nil {
		fields = append(fields, strategyperformance.FieldMaxDrawdown)
	}
	if m.sharpe_ratio != nil {
		fields = append(fields, strategyperformance.FieldSharpeRatio)
	}
	if m.created_at != nil {
		fields = append(fields, strategyperformance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, strategyperformance.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategyPerformanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategyperformance.FieldStrategyID:
		return m.StrategyID()
	case strategyperformance.FieldTotalReturn:
		return m.TotalReturn()
	case strategyperformance.FieldWinRate:
		return m.WinRate()
	case strategyperformance.FieldProfitLoss:
		return m.ProfitLoss()
	case strategyperformance.FieldTradeCount:
		return m.TradeCount()
	case strategyperformance.FieldLastTradeTime:
		return m.LastTradeTime()
	case strategyperformance.FieldMaxDrawdown:
		return m.MaxDrawdown()
	case strategyperformance.FieldSharpeRatio:
		return m.SharpeRatio()
	case strategyperformance.FieldCreatedAt:
		return m.CreatedAt()
	case strategyperformance.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategyPerformanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategyperformance.FieldStrategyID:
		return m.OldStrategyID(ctx)
	case strategyperformance.FieldTotalReturn:
		return m.OldTotalReturn(ctx)
	case strategyperformance.FieldWinRate:
		return m.OldWinRate(ctx)
	case strategyperformance.FieldProfitLoss:
		return m.OldProfitLoss(ctx)
	case strategyperformance.FieldTradeCount:
		return m.OldTradeCount(ctx)
	case strategyperformance.FieldLastTradeTime:
		return m.OldLastTradeTime(ctx)
	case strategyperformance.FieldMaxDrawdown:
		return m.OldMaxDrawdown(ctx)
	case strategyperformance.FieldSharpeRatio:
		return m.OldSharpeRatio(ctx)
	case strategyperformance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case strategyperformance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown StrategyPerformance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyPerformanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategyperformance.FieldStrategyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyID(v)
		return nil
	case strategyperformance.FieldTotalReturn:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalReturn(v)
		return nil
	case strategyperformance.FieldWinRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWinRate(v)
		return nil
	case strategyperformance.FieldProfitLoss:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfitLoss(v)
		return nil
	case strategyperformance.FieldTradeCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradeCount(v)
		return nil
	case strategyperformance.FieldLastTradeTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastTradeTime(v)
		return nil
	case strategyperformance.FieldMaxDrawdown:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxDrawdown(v)
		return nil
	case strategyperformance.FieldSharpeRatio:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSharpeRatio(v)
		return nil
	case strategyperformance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case strategyperformance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StrategyPerformance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategyPerformanceMutation) AddedFields() []string {
	var fields []string
	if m.addtrade_count != nil {
		fields = append(fields, strategyperformance.FieldTradeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategyPerformanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case strategyperformance.FieldTradeCount:
		return m.AddedTradeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyPerformanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case strategyperformance.FieldTradeCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTradeCount(v)
		return nil
	}
	return fmt.Errorf("unknown StrategyPerformance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategyPerformanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(strategyperformance.FieldLastTradeTime) {
		fields = append(fields, strategyperformance.FieldLastTradeTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategyPerformanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategyPerformanceMutation) ClearField(name string) error {
	switch name {
	case strategyperformance.FieldLastTradeTime:
		m.ClearLastTradeTime()
		return nil
	}
	return fmt.Errorf("unknown StrategyPerformance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategyPerformanceMutation) ResetField(name string) error {
	switch name {
	case strategyperformance.FieldStrategyID:
		m.ResetStrategyID()
		return nil
	case strategyperformance.FieldTotalReturn:
		m.ResetTotalReturn()
		return nil
	case strategyperformance.FieldWinRate:
		m.ResetWinRate()
		return nil
	case strategyperformance.FieldProfitLoss:
		m.ResetProfitLoss()
		return nil
	case strategyperformance.FieldTradeCount:
		m.ResetTradeCount()
		return nil
	case strategyperformance.FieldLastTradeTime:
		m.ResetLastTradeTime()
		return nil
	case strategyperformance.FieldMaxDrawdown:
		m.ResetMaxDrawdown()
		return nil
	case strategyperformance.FieldSharpeRatio:
		m.ResetSharpeRatio()
		return nil
	case strategyperformance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case strategyperformance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown StrategyPerformance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategyPerformanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.strategy != nil {
		edges = append(edges, strategyperformance.EdgeStrategy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategyPerformanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case strategyperformance.EdgeStrategy:
		if id := m.strategy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategyPerformanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategyPerformanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategyPerformanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstrategy {
		edges = append(edges, strategyperformance.EdgeStrategy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategyPerformanceMutation) EdgeCleared(name string) bool {
	switch name {
	case strategyperformance.EdgeStrategy:
		return m.clearedstrategy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategyPerformanceMutation) ClearEdge(name string) error {
	switch name {
	case strategyperformance.EdgeStrategy:
		m.ClearStrategy()
		return nil
	}
	return fmt.Errorf("unknown StrategyPerformance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategyPerformanceMutation) ResetEdge(name string) error {
	switch name {
	case strategyperformance.EdgeStrategy:
		m.ResetStrategy()
		return nil
	}
	return fmt.Errorf("unknown StrategyPerformance edge %s", name)
}

// StrategyStatusMutation represents an operation that mutates the StrategyStatus nodes in the graph.
type StrategyStatusMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	status             *strategystatus.Status
	last_execution     *time.Time
	execution_count    *int64
	addexecution_count *int64
	error_message      *string
	uptime_seconds     *int64
	adduptime_seconds  *int64
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	strategy           *uuid.UUID
	clearedstrategy    bool
	done               bool
	oldValue           func(context.Context) (*StrategyStatus, error)
	predicates         []predicate.StrategyStatus
}

var _ ent.Mutation = (*StrategyStatusMutation)(nil)

// strategystatusOption allows management of the mutation configuration using functional options.
type strategystatusOption func(*StrategyStatusMutation)

// newStrategyStatusMutation creates new mutation for the StrategyStatus entity.
func newStrategyStatusMutation(c config, op Op, opts ...strategystatusOption) *StrategyStatusMutation {
	m := &StrategyStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategyStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategyStatusID sets the ID field of the mutation.
func withStrategyStatusID(id int) strategystatusOption {
	return func(m *StrategyStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *StrategyStatus
		)
		m.oldValue = func(ctx context.Context) (*StrategyStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StrategyStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategyStatus sets the old StrategyStatus of the mutation.
func withStrategyStatus(node *StrategyStatus) strategystatusOption {
	return func(m *StrategyStatusMutation) {
		m.oldValue = func(context.Context) (*StrategyStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategyStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategyStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategyStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategyStatusMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StrategyStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStrategyID sets the "strategy_id" field.
func (m *StrategyStatusMutation) SetStrategyID(u uuid.UUID) {
	m.strategy = &u
}

// StrategyID returns the value of the "strategy_id" field in the mutation.
func (m *StrategyStatusMutation) StrategyID() (r uuid.UUID, exists bool) {
	v := m.strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyID returns the old "strategy_id" field's value of the StrategyStatus entity.
// If the StrategyStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyStatusMutation) OldStrategyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyID: %w", err)
	}
	return oldValue.StrategyID, nil
}

// ResetStrategyID resets all changes to the "strategy_id" field.
func (m *StrategyStatusMutation) ResetStrategyID() {
	m.strategy = nil
}

// SetStatus sets the "status" field.
func (m *StrategyStatusMutation) SetStatus(s strategystatus.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StrategyStatusMutation) Status() (r strategystatus.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the StrategyStatus entity.
// If the StrategyStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyStatusMutation) OldStatus(ctx context.Context) (v strategystatus.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *StrategyStatusMutation) ResetStatus() {
	m.status = nil
}

// SetLastExecution sets the "last_execution" field.
func (m *StrategyStatusMutation) SetLastExecution(t time.Time) {
	m.last_execution = &t
}

// LastExecution returns the value of the "last_execution" field in the mutation.
func (m *StrategyStatusMutation) LastExecution() (r time.Time, exists bool) {
	v := m.last_execution
	if v == nil {
		return
	}
	return *v, true
}

// OldLastExecution returns the old "last_execution" field's value of the StrategyStatus entity.
// If the StrategyStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyStatusMutation) OldLastExecution(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastExecution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastExecution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastExecution: %w", err)
	}
	return oldValue.LastExecution, nil
}

// ClearLastExecution clears the value of the "last_execution" field.
func (m *StrategyStatusMutation) ClearLastExecution() {
	m.last_execution = nil
	m.clearedFields[strategystatus.FieldLastExecution] = struct{}{}
}

// LastExecutionCleared returns if the "last_execution" field was cleared in this mutation.
func (m *StrategyStatusMutation) LastExecutionCleared() bool {
	_, ok := m.clearedFields[strategystatus.FieldLastExecution]
	return ok
}

// ResetLastExecution resets all changes to the "last_execution" field.
func (m *StrategyStatusMutation) ResetLastExecution() {
	m.last_execution = nil
	delete(m.clearedFields, strategystatus.FieldLastExecution)
}

// SetExecutionCount sets the "execution_count" field.
func (m *StrategyStatusMutation) SetExecutionCount(i int64) {
	m.execution_count = &i
	m.addexecution_count = nil
}

// ExecutionCount returns the value of the "execution_count" field in the mutation.
func (m *StrategyStatusMutation) ExecutionCount() (r int64, exists bool) {
	v := m.execution_count
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionCount returns the old "execution_count" field's value of the StrategyStatus entity.
// If the StrategyStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyStatusMutation) OldExecutionCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionCount: %w", err)
	}
	return oldValue.ExecutionCount, nil
}

// AddExecutionCount adds i to the "execution_count" field.
func (m *StrategyStatusMutation) AddExecutionCount(i int64) {
	if m.addexecution_count != nil {
		*m.addexecution_count += i
	} else {
		m.addexecution_count = &i
	}
}

// AddedExecutionCount returns the value that was added to the "execution_count" field in this mutation.
func (m *StrategyStatusMutation) AddedExecutionCount() (r int64, exists bool) {
	v := m.addexecution_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetExecutionCount resets all changes to the "execution_count" field.
func (m *StrategyStatusMutation) ResetExecutionCount() {
	m.execution_count = nil
	m.addexecution_count = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *StrategyStatusMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *StrategyStatusMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the StrategyStatus entity.
// If the StrategyStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyStatusMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *StrategyStatusMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[strategystatus.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *StrategyStatusMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[strategystatus.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *StrategyStatusMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, strategystatus.FieldErrorMessage)
}

// SetUptimeSeconds sets the "uptime_seconds" field.
func (m *StrategyStatusMutation) SetUptimeSeconds(i int64) {
	m.uptime_seconds = &i
	m.adduptime_seconds = nil
}

// UptimeSeconds returns the value of the "uptime_seconds" field in the mutation.
func (m *StrategyStatusMutation) UptimeSeconds() (r int64, exists bool) {
	v := m.uptime_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldUptimeSeconds returns the old "uptime_seconds" field's value of the StrategyStatus entity.
// If the StrategyStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyStatusMutation) OldUptimeSeconds(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUptimeSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUptimeSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUptimeSeconds: %w", err)
	}
	return oldValue.UptimeSeconds, nil
}

// AddUptimeSeconds adds i to the "uptime_seconds" field.
func (m *StrategyStatusMutation) AddUptimeSeconds(i int64) {
	if m.adduptime_seconds != nil {
		*m.adduptime_seconds += i
	} else {
		m.adduptime_seconds = &i
	}
}

// AddedUptimeSeconds returns the value that was added to the "uptime_seconds" field in this mutation.
func (m *StrategyStatusMutation) AddedUptimeSeconds() (r int64, exists bool) {
	v := m.adduptime_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetUptimeSeconds resets all changes to the "uptime_seconds" field.
func (m *StrategyStatusMutation) ResetUptimeSeconds() {
	m.uptime_seconds = nil
	m.adduptime_seconds = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StrategyStatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StrategyStatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StrategyStatus entity.
// If the StrategyStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyStatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StrategyStatusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StrategyStatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StrategyStatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StrategyStatus entity.
// If the StrategyStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyStatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StrategyStatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearStrategy clears the "strategy" edge to the Strategy entity.
func (m *StrategyStatusMutation) ClearStrategy() {
	m.clearedstrategy = true
	m.clearedFields[strategystatus.FieldStrategyID] = struct{}{}
}

// StrategyCleared reports if the "strategy" edge to the Strategy entity was cleared.
func (m *StrategyStatusMutation) StrategyCleared() bool {
	return m.clearedstrategy
}

// StrategyIDs returns the "strategy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StrategyID instead. It exists only for internal usage by the builders.
func (m *StrategyStatusMutation) StrategyIDs() (ids []uuid.UUID) {
	if id := m.strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStrategy resets all changes to the "strategy" edge.
func (m *StrategyStatusMutation) ResetStrategy() {
	m.strategy = nil
	m.clearedstrategy = false
}

// Where appends a list predicates to the StrategyStatusMutation builder.
func (m *StrategyStatusMutation) Where(ps ...predicate.StrategyStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StrategyStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StrategyStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StrategyStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StrategyStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StrategyStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StrategyStatus).
func (m *StrategyStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategyStatusMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.strategy != nil {
		fields = append(fields, strategystatus.FieldStrategyID)
	}
	if m.status != nil {
		fields = append(fields, strategystatus.FieldStatus)
	}
	if m.last_execution != nil {
		fields = append(fields, strategystatus.FieldLastExecution)
	}
	if m.execution_count != nil {
		fields = append(fields, strategystatus.FieldExecutionCount)
	}
	if m.error_message != nil {
		fields = append(fields, strategystatus.FieldErrorMessage)
	}
	if m.uptime_seconds != nil {
		fields = append(fields, strategystatus.FieldUptimeSeconds)
	}
	if m.created_at != nil {
		fields = append(fields, strategystatus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, strategystatus.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategyStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategystatus.FieldStrategyID:
		return m.StrategyID()
	case strategystatus.FieldStatus:
		return m.Status()
	case strategystatus.FieldLastExecution:
		return m.LastExecution()
	case strategystatus.FieldExecutionCount:
		return m.ExecutionCount()
	case strategystatus.FieldErrorMessage:
		return m.ErrorMessage()
	case strategystatus.FieldUptimeSeconds:
		return m.UptimeSeconds()
	case strategystatus.FieldCreatedAt:
		return m.CreatedAt()
	case strategystatus.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategyStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategystatus.FieldStrategyID:
		return m.OldStrategyID(ctx)
	case strategystatus.FieldStatus:
		return m.OldStatus(ctx)
	case strategystatus.FieldLastExecution:
		return m.OldLastExecution(ctx)
	case strategystatus.FieldExecutionCount:
		return m.OldExecutionCount(ctx)
	case strategystatus.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case strategystatus.FieldUptimeSeconds:
		return m.OldUptimeSeconds(ctx)
	case strategystatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case strategystatus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown StrategyStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategystatus.FieldStrategyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyID(v)
		return nil
	case strategystatus.FieldStatus:
		v, ok := value.(strategystatus.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case strategystatus.FieldLastExecution:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastExecution(v)
		return nil
	case strategystatus.FieldExecutionCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionCount(v)
		return nil
	case strategystatus.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case strategystatus.FieldUptimeSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUptimeSeconds(v)
		return nil
	case strategystatus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case strategystatus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StrategyStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategyStatusMutation) AddedFields() []string {
	var fields []string
	if m.addexecution_count != nil {
		fields = append(fields, strategystatus.FieldExecutionCount)
	}
	if m.adduptime_seconds != nil {
		fields = append(fields, strategystatus.FieldUptimeSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategyStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case strategystatus.FieldExecutionCount:
		return m.AddedExecutionCount()
	case strategystatus.FieldUptimeSeconds:
		return m.AddedUptimeSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case strategystatus.FieldExecutionCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutionCount(v)
		return nil
	case strategystatus.FieldUptimeSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUptimeSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown StrategyStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategyStatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(strategystatus.FieldLastExecution) {
		fields = append(fields, strategystatus.FieldLastExecution)
	}
	if m.FieldCleared(strategystatus.FieldErrorMessage) {
		fields = append(fields, strategystatus.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategyStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategyStatusMutation) ClearField(name string) error {
	switch name {
	case strategystatus.FieldLastExecution:
		m.ClearLastExecution()
		return nil
	case strategystatus.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown StrategyStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategyStatusMutation) ResetField(name string) error {
	switch name {
	case strategystatus.FieldStrategyID:
		m.ResetStrategyID()
		return nil
	case strategystatus.FieldStatus:
		m.ResetStatus()
		return nil
	case strategystatus.FieldLastExecution:
		m.ResetLastExecution()
		return nil
	case strategystatus.FieldExecutionCount:
		m.ResetExecutionCount()
		return nil
	case strategystatus.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case strategystatus.FieldUptimeSeconds:
		m.ResetUptimeSeconds()
		return nil
	case strategystatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case strategystatus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown StrategyStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategyStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.strategy != nil {
		edges = append(edges, strategystatus.EdgeStrategy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategyStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case strategystatus.EdgeStrategy:
		if id := m.strategy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategyStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategyStatusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategyStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstrategy {
		edges = append(edges, strategystatus.EdgeStrategy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategyStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case strategystatus.EdgeStrategy:
		return m.clearedstrategy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategyStatusMutation) ClearEdge(name string) error {
	switch name {
	case strategystatus.EdgeStrategy:
		m.ClearStrategy()
		return nil
	}
	return fmt.Errorf("unknown StrategyStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategyStatusMutation) ResetEdge(name string) error {
	switch name {
	case strategystatus.EdgeStrategy:
		m.ResetStrategy()
		return nil
	}
	return fmt.Errorf("unknown StrategyStatus edge %s", name)
}

// StrategyTemplateMutation represents an operation that mutates the StrategyTemplate nodes in the graph.
type StrategyTemplateMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	description       *string
	category          *string
	template_config   *map[string]interface{}
	input_schema      *map[string]interface{}
	version           *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	strategies        map[uuid.UUID]struct{}
	removedstrategies map[uuid.UUID]struct{}
	clearedstrategies bool
	done              bool
	oldValue          func(context.Context) (*StrategyTemplate, error)
	predicates        []predicate.StrategyTemplate
}

var _ ent.Mutation = (*StrategyTemplateMutation)(nil)

// strategytemplateOption allows management of the mutation configuration using functional options.
type strategytemplateOption func(*StrategyTemplateMutation)

// newStrategyTemplateMutation creates new mutation for the StrategyTemplate entity.
func newStrategyTemplateMutation(c config, op Op, opts ...strategytemplateOption) *StrategyTemplateMutation {
	m := &StrategyTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategyTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategyTemplateID sets the ID field of the mutation.
func withStrategyTemplateID(id uuid.UUID) strategytemplateOption {
	return func(m *StrategyTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *StrategyTemplate
		)
		m.oldValue = func(ctx context.Context) (*StrategyTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StrategyTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategyTemplate sets the old StrategyTemplate of the mutation.
func withStrategyTemplate(node *StrategyTemplate) strategytemplateOption {
	return func(m *StrategyTemplateMutation) {
		m.oldValue = func(context.Context) (*StrategyTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategyTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategyTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StrategyTemplate entities.
func (m *StrategyTemplateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategyTemplateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategyTemplateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StrategyTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *StrategyTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StrategyTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StrategyTemplate entity.
// If the StrategyTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StrategyTemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *StrategyTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StrategyTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the StrategyTemplate entity.
// If the StrategyTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyTemplateMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StrategyTemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[strategytemplate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StrategyTemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[strategytemplate.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StrategyTemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, strategytemplate.FieldDescription)
}

// SetCategory sets the "category" field.
func (m *StrategyTemplateMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *StrategyTemplateMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the StrategyTemplate entity.
// If the StrategyTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyTemplateMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *StrategyTemplateMutation) ResetCategory() {
	m.category = nil
}

// SetTemplateConfig sets the "template_config" field.
func (m *StrategyTemplateMutation) SetTemplateConfig(value map[string]interface{}) {
	m.template_config = &value
}

// TemplateConfig returns the value of the "template_config" field in the mutation.
func (m *StrategyTemplateMutation) TemplateConfig() (r map[string]interface{}, exists bool) {
	v := m.template_config
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateConfig returns the old "template_config" field's value of the StrategyTemplate entity.
// If the StrategyTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyTemplateMutation) OldTemplateConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateConfig: %w", err)
	}
	return oldValue.TemplateConfig, nil
}

// ResetTemplateConfig resets all changes to the "template_config" field.
func (m *StrategyTemplateMutation) ResetTemplateConfig() {
	m.template_config = nil
}

// SetInputSchema sets the "input_schema" field.
func (m *StrategyTemplateMutation) SetInputSchema(value map[string]interface{}) {
	m.input_schema = &value
}

// InputSchema returns the value of the "input_schema" field in the mutation.
func (m *StrategyTemplateMutation) InputSchema() (r map[string]interface{}, exists bool) {
	v := m.input_schema
	if v == nil {
		return
	}
	return *v, true
}

// OldInputSchema returns the old "input_schema" field's value of the StrategyTemplate entity.
// If the StrategyTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyTemplateMutation) OldInputSchema(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputSchema: %w", err)
	}
	return oldValue.InputSchema, nil
}

// ResetInputSchema resets all changes to the "input_schema" field.
func (m *StrategyTemplateMutation) ResetInputSchema() {
	m.input_schema = nil
}

// SetVersion sets the "version" field.
func (m *StrategyTemplateMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *StrategyTemplateMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the StrategyTemplate entity.
// If the StrategyTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyTemplateMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *StrategyTemplateMutation) ResetVersion() {
	m.version = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StrategyTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StrategyTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StrategyTemplate entity.
// If the StrategyTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StrategyTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StrategyTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StrategyTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StrategyTemplate entity.
// If the StrategyTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StrategyTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddStrategyIDs adds the "strategies" edge to the Strategy entity by ids.
func (m *StrategyTemplateMutation) AddStrategyIDs(ids ...uuid.UUID) {
	if m.strategies == nil {
		m.strategies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.strategies[ids[i]] = struct{}{}
	}
}

// ClearStrategies clears the "strategies" edge to the Strategy entity.
func (m *StrategyTemplateMutation) ClearStrategies() {
	m.clearedstrategies = true
}

// StrategiesCleared reports if the "strategies" edge to the Strategy entity was cleared.
func (m *StrategyTemplateMutation) StrategiesCleared() bool {
	return m.clearedstrategies
}

// RemoveStrategyIDs removes the "strategies" edge to the Strategy entity by IDs.
func (m *StrategyTemplateMutation) RemoveStrategyIDs(ids ...uuid.UUID) {
	if m.removedstrategies == nil {
		m.removedstrategies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.strategies, ids[i])
		m.removedstrategies[ids[i]] = struct{}{}
	}
}

// RemovedStrategies returns the removed IDs of the "strategies" edge to the Strategy entity.
func (m *StrategyTemplateMutation) RemovedStrategiesIDs() (ids []uuid.UUID) {
	for id := range m.removedstrategies {
		ids = append(ids, id)
	}
	return
}

// StrategiesIDs returns the "strategies" edge IDs in the mutation.
func (m *StrategyTemplateMutation) StrategiesIDs() (ids []uuid.UUID) {
	for id := range m.strategies {
		ids = append(ids, id)
	}
	return
}

// ResetStrategies resets all changes to the "strategies" edge.
func (m *StrategyTemplateMutation) ResetStrategies() {
	m.strategies = nil
	m.clearedstrategies = false
	m.removedstrategies = nil
}

// Where appends a list predicates to the StrategyTemplateMutation builder.
func (m *StrategyTemplateMutation) Where(ps ...predicate.StrategyTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StrategyTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StrategyTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StrategyTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StrategyTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StrategyTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StrategyTemplate).
func (m *StrategyTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategyTemplateMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, strategytemplate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, strategytemplate.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, strategytemplate.FieldCategory)
	}
	if m.template_config != nil {
		fields = append(fields, strategytemplate.FieldTemplateConfig)
	}
	if m.input_schema != nil {
		fields = append(fields, strategytemplate.FieldInputSchema)
	}
	if m.version != nil {
		fields = append(fields, strategytemplate.FieldVersion)
	}
	if m.created_at != nil {
		fields = append(fields, strategytemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, strategytemplate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategyTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategytemplate.FieldName:
		return m.Name()
	case strategytemplate.FieldDescription:
		return m.Description()
	case strategytemplate.FieldCategory:
		return m.Category()
	case strategytemplate.FieldTemplateConfig:
		return m.TemplateConfig()
	case strategytemplate.FieldInputSchema:
		return m.InputSchema()
	case strategytemplate.FieldVersion:
		return m.Version()
	case strategytemplate.FieldCreatedAt:
		return m.CreatedAt()
	case strategytemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategyTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategytemplate.FieldName:
		return m.OldName(ctx)
	case strategytemplate.FieldDescription:
		return m.OldDescription(ctx)
	case strategytemplate.FieldCategory:
		return m.OldCategory(ctx)
	case strategytemplate.FieldTemplateConfig:
		return m.OldTemplateConfig(ctx)
	case strategytemplate.FieldInputSchema:
		return m.OldInputSchema(ctx)
	case strategytemplate.FieldVersion:
		return m.OldVersion(ctx)
	case strategytemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case strategytemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown StrategyTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategytemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case strategytemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case strategytemplate.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case strategytemplate.FieldTemplateConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateConfig(v)
		return nil
	case strategytemplate.FieldInputSchema:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputSchema(v)
		return nil
	case strategytemplate.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case strategytemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case strategytemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StrategyTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategyTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategyTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StrategyTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategyTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(strategytemplate.FieldDescription) {
		fields = append(fields, strategytemplate.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategyTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategyTemplateMutation) ClearField(name string) error {
	switch name {
	case strategytemplate.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown StrategyTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategyTemplateMutation) ResetField(name string) error {
	switch name {
	case strategytemplate.FieldName:
		m.ResetName()
		return nil
	case strategytemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case strategytemplate.FieldCategory:
		m.ResetCategory()
		return nil
	case strategytemplate.FieldTemplateConfig:
		m.ResetTemplateConfig()
		return nil
	case strategytemplate.FieldInputSchema:
		m.ResetInputSchema()
		return nil
	case strategytemplate.FieldVersion:
		m.ResetVersion()
		return nil
	case strategytemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case strategytemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown StrategyTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategyTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.strategies != nil {
		edges = append(edges, strategytemplate.EdgeStrategies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategyTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case strategytemplate.EdgeStrategies:
		ids := make([]ent.Value, 0, len(m.strategies))
		for id := range m.strategies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategyTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstrategies != nil {
		edges = append(edges, strategytemplate.EdgeStrategies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategyTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case strategytemplate.EdgeStrategies:
		ids := make([]ent.Value, 0, len(m.removedstrategies))
		for id := range m.removedstrategies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategyTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstrategies {
		edges = append(edges, strategytemplate.EdgeStrategies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategyTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case strategytemplate.EdgeStrategies:
		return m.clearedstrategies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategyTemplateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown StrategyTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategyTemplateMutation) ResetEdge(name string) error {
	switch name {
	case strategytemplate.EdgeStrategies:
		m.ResetStrategies()
		return nil
	}
	return fmt.Errorf("unknown StrategyTemplate edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	nickname          *string
	email             *string
	password          *string
	is_valid          *bool
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	strategies        map[uuid.UUID]struct{}
	removedstrategies map[uuid.UUID]struct{}
	clearedstrategies bool
	portfolios        map[uuid.UUID]struct{}
	removedportfolios map[uuid.UUID]struct{}
	clearedportfolios bool
	done              bool
	oldValue          func(context.Context) (*User, error)
	predicates        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetIsValid sets the "is_valid" field.
func (m *UserMutation) SetIsValid(b bool) {
	m.is_valid = &b
}

// IsValid returns the value of the "is_valid" field in the mutation.
func (m *UserMutation) IsValid() (r bool, exists bool) {
	v := m.is_valid
	if v == nil {
		return
	}
	return *v, true
}

// OldIsValid returns the old "is_valid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsValid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsValid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsValid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsValid: %w", err)
	}
	return oldValue.IsValid, nil
}

// ResetIsValid resets all changes to the "is_valid" field.
func (m *UserMutation) ResetIsValid() {
	m.is_valid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// AddStrategyIDs adds the "strategies" edge to the Strategy entity by ids.
func (m *UserMutation) AddStrategyIDs(ids ...uuid.UUID) {
	if m.strategies == nil {
		m.strategies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.strategies[ids[i]] = struct{}{}
	}
}

// ClearStrategies clears the "strategies" edge to the Strategy entity.
func (m *UserMutation) ClearStrategies() {
	m.clearedstrategies = true
}

// StrategiesCleared reports if the "strategies" edge to the Strategy entity was cleared.
func (m *UserMutation) StrategiesCleared() bool {
	return m.clearedstrategies
}

// RemoveStrategyIDs removes the "strategies" edge to the Strategy entity by IDs.
func (m *UserMutation) RemoveStrategyIDs(ids ...uuid.UUID) {
	if m.removedstrategies == nil {
		m.removedstrategies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.strategies, ids[i])
		m.removedstrategies[ids[i]] = struct{}{}
	}
}

// RemovedStrategies returns the removed IDs of the "strategies" edge to the Strategy entity.
func (m *UserMutation) RemovedStrategiesIDs() (ids []uuid.UUID) {
	for id := range m.removedstrategies {
		ids = append(ids, id)
	}
	return
}

// StrategiesIDs returns the "strategies" edge IDs in the mutation.
func (m *UserMutation) StrategiesIDs() (ids []uuid.UUID) {
	for id := range m.strategies {
		ids = append(ids, id)
	}
	return
}

// ResetStrategies resets all changes to the "strategies" edge.
func (m *UserMutation) ResetStrategies() {
	m.strategies = nil
	m.clearedstrategies = false
	m.removedstrategies = nil
}

// AddPortfolioIDs adds the "portfolios" edge to the Portfolio entity by ids.
func (m *UserMutation) AddPortfolioIDs(ids ...uuid.UUID) {
	if m.portfolios == nil {
		m.portfolios = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.portfolios[ids[i]] = struct{}{}
	}
}

// ClearPortfolios clears the "portfolios" edge to the Portfolio entity.
func (m *UserMutation) ClearPortfolios() {
	m.clearedportfolios = true
}

// PortfoliosCleared reports if the "portfolios" edge to the Portfolio entity was cleared.
func (m *UserMutation) PortfoliosCleared() bool {
	return m.clearedportfolios
}

// RemovePortfolioIDs removes the "portfolios" edge to the Portfolio entity by IDs.
func (m *UserMutation) RemovePortfolioIDs(ids ...uuid.UUID) {
	if m.removedportfolios == nil {
		m.removedportfolios = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.portfolios, ids[i])
		m.removedportfolios[ids[i]] = struct{}{}
	}
}

// RemovedPortfolios returns the removed IDs of the "portfolios" edge to the Portfolio entity.
func (m *UserMutation) RemovedPortfoliosIDs() (ids []uuid.UUID) {
	for id := range m.removedportfolios {
		ids = append(ids, id)
	}
	return
}

// PortfoliosIDs returns the "portfolios" edge IDs in the mutation.
func (m *UserMutation) PortfoliosIDs() (ids []uuid.UUID) {
	for id := range m.portfolios {
		ids = append(ids, id)
	}
	return
}

// ResetPortfolios resets all changes to the "portfolios" edge.
func (m *UserMutation) ResetPortfolios() {
	m.portfolios = nil
	m.clearedportfolios = false
	m.removedportfolios = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.is_valid != nil {
		fields = append(fields, user.FieldIsValid)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldIsValid:
		return m.IsValid()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldIsValid:
		return m.OldIsValid(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldIsValid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsValid(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldIsValid:
		m.ResetIsValid()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.strategies != nil {
		edges = append(edges, user.EdgeStrategies)
	}
	if m.portfolios != nil {
		edges = append(edges, user.EdgePortfolios)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeStrategies:
		ids := make([]ent.Value, 0, len(m.strategies))
		for id := range m.strategies {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePortfolios:
		ids := make([]ent.Value, 0, len(m.portfolios))
		for id := range m.portfolios {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedstrategies != nil {
		edges = append(edges, user.EdgeStrategies)
	}
	if m.removedportfolios != nil {
		edges = append(edges, user.EdgePortfolios)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeStrategies:
		ids := make([]ent.Value, 0, len(m.removedstrategies))
		for id := range m.removedstrategies {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePortfolios:
		ids := make([]ent.Value, 0, len(m.removedportfolios))
		for id := range m.removedportfolios {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstrategies {
		edges = append(edges, user.EdgeStrategies)
	}
	if m.clearedportfolios {
		edges = append(edges, user.EdgePortfolios)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeStrategies:
		return m.clearedstrategies
	case user.EdgePortfolios:
		return m.clearedportfolios
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeStrategies:
		m.ResetStrategies()
		return nil
	case user.EdgePortfolios:
		m.ResetPortfolios()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
